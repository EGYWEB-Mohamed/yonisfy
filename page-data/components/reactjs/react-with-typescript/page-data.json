{"componentChunkName":"component---src-templates-docs-js","path":"/components/reactjs/react-with-typescript","result":{"data":{"site":{"siteMetadata":{"title":"Yonisfy","docsLocation":"https://github.com/mohammedelzanaty/yonisfy","docsLocationType":"github","editable":true}},"mdx":{"fields":{"id":"2a280570-ae4d-5bb7-b6b4-30ccae68f12f","title":"React with TypeScript","slug":"/components/reactjs/react-with-typescript"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"React with TypeScript\",\n  \"showMetadata\": true,\n  \"editable\": true,\n  \"showToc\": true,\n  \"order\": 0,\n  \"tocDepth\": 3\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Tip = makeShortcode(\"Tip\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"TypeScript is a superset of JavaScript which primarily provides optional static typing, classes, and interfaces.\")), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Why use TypeScript\"), mdx(\"ul\", {\n    parentName: \"section\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Easy to read and understand components\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Type Checking at compile time is way better than things \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"crashing-or-worse-behaving\"), \" unexpectedly at run time.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"You get a better development experience because \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"autocomplete\"), \" knows more about what you'r intending on doing.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Large \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"codebase stays more maintainable\"), \" because you're able to put guardrails on how your code can be used.\"))), mdx(\"p\", {\n    parentName: \"section\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://blog.bitsrc.io/5-strong-reasons-to-use-typescript-with-react-bc987da5d907\"\n  }, \"Read More\"), \" \\uD83D\\uDE09\")), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"The Fundamentals\")), mdx(\"section\", null, mdx(\"h3\", {\n    parentName: \"section\"\n  }, \"Basics\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const User = () => {\\n  return (\\n    <main>\\n      <h1>Hello</h1>\\n      <p>My Name Is [NAME_HERE]</p>\\n    </main>\\n  );\\n};\\n\\nconst Application = () => <User />;\\n\\nexport default Application;\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Above, we can see a fairly simple \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"User\"), \" component. As it stands right now, it doesn't take any \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"props\"), \" or hold onto any \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"state\"), \". For our purposes, it might as well just be some static HTML. It really doesn't even need to be React.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Is this JavaScript or TypeScript? The answer is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Out of the box\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"TypeScript\"), \" is going to try to do everything in its power to infer all of the types for you.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"This is a simple, but core concept that we're going to playing with during our time together. TypeScript is trying its hardest to stay out of your way. Occasionally, we need to step in a give it some hints about what we're intending to do. If you find yourself fighting with TypeScript\\u2014then it's worth taking a step back and considering your approach.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Looking at the component in this example. TypeScript has figured out that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"User\"), \", in this case, is a function that takes no arguments and returns a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JSX.Element\"), \" , which is a type it knows about from React.\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const User: () => JSX.Element;\\n\"))), mdx(\"section\", null, mdx(\"h3\", {\n    parentName: \"section\"\n  }, \"Refactoring from PropTypes\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"In JavaScript, we've traditionally used \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.PropTypes\"), \" in order to make sure that we were passing\\nthe correct types to our React components. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.PropTypes\"), \" would only run at run-time and in\\ndevelopment and would spit out \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"console warnings\"), \" in the event that the component received the wrong types. This was good, but we can do better with TypeScript\\u2014specifically, we can do this statically and at compile time.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Let's take a look at how this might look in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JavaScript\"), \".\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import * as PropTypes from \\\"prop-types\\\";\\n\\nconst User = ({ name }) => <h1>Welcome, {name}!</h1>;\\n\\nUser.propTypes = {\\n  name: PropTypes.string,\\n};\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"There is no need for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PropTypes\"), \" in TypeScript as that's pretty much a large part of what TypeScript does on our behalf.\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"type UserProps = { name: string };\\n\\nconst User = ({ name }: UserProps) => <h1>Welcome, {name}!</h1>;\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"TypeScript has now created the following type for this component:\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const User: ({ name }: UserProps) => JSX.Element;\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Inline Type Declarations\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"An aside\"), \": You could also do this inline if it makes you happier. But, it shouldn't make you happier, because it's one of those things that will get out of control fairly quickly.\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const User = ({ name }: { name: string }) => <h1>Welcome, {name}!</h1>;\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"This is fine for one prop, but it doesn't scale particularly well. If the number of curly braces is intimidating to you, let's think about what this looks like without all of the destructuring in place.\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"type UserProps = { name: string };\\n\\nconst User = (props: UserProps) => <h1>Welcome, {props.name}!</h1>;\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"This is not dissimilar from if we did something simple, like this:\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"const addTwo = (n: number) => n + 2;\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"We're just annotating our functions with some extra information to tell TypeScript what we're intending.\")), mdx(\"section\", null, mdx(\"h3\", {\n    parentName: \"section\"\n  }, \"Commonly-Used Props\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Let's take a moment to look at some of the types that go along with some of\\nthe more common props that we tend to see in React applications.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"For starters, we have our basic primitives.\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"type User = {\\n  email: string;\\n  age: string;\\n  isMarried: boolean;\\n};\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"We can also have arrays or collections of primitives.\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"type User = {\\n  hobbies: string[];\\n};\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Sometimes, we don't want to allow \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"any\"), \" string\\u2014only certain strings. We can use a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html\"\n  }, \"union type\"), \" to represent this.\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"type User = {\\n  hobbies: string[];\\n  status: \\\"loading\\\" | \\\"error\\\" | \\\"success\\\";\\n};\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"It's not uncommon for us to find ourselves using objects in JavaScript (erm, TypeScript).\\nSo, what would that look like?\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"type User = {\\n  login: {}; // Can have any properties and values.\\n  name: {\\n    title: string;\\n    first: string;\\n    last: string;\\n  };\\n  location: {\\n    city: string;\\n    state: string;\\n    country: string;\\n  }[]; // An array of objects of a certain shape.\\n};\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"We could refactor this a bit. (I know, it's a contrived example, but go along with it.)\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"type Name = {\\n  title: string;\\n  first: string;\\n  last: string;\\n};\\n\\ntype Location = {\\n  city: string;\\n  state: string;\\n  country: string;\\n};\\n\\ntype User = {\\n  name: Name;\\n  location: Location;\\n};\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"So, if you look at our two object examples above, we're missing something.\"), mdx(\"ul\", {\n    parentName: \"section\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"{}\"), \" will allow for an object with any keys and any values.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"{ title: string; first: string; last: string; }\"), \" will only allow for an object with \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"three\"), \" keys: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"title\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"first\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"last\"), \" as long as those values are strings.\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"But, what if we wanted to find a happy medium? What if we wanted a situation where we said, \\\"Listen, the key can be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"any\"), \" string and the value has to be of a certain type.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"That might look something like this:\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"type ItemHash = {\\n  [key: string]: Item;\\n};\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Or, if we wanted to say the keys are number and the values are strings, it would look like this:\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"type Dictionary = {\\n  [key: number]: string;\\n};\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Another way of writing either of those would be as follows:\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"Record<string, Item>\\nRecord<number, string>\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"I prefer the first syntax, personally. But, this is your life. You do what you want.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Okay, so we tend to also pass \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"functions\"), \" around, right? What does that look like?\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"type UserProps = {\\n  // Does not take any arguments. Does not return anything.\\n  onHover: () => void;\\n  // Takes a number. Returns nothing (e.g. undefined).\\n  onChange: (id: number) => void;\\n  // Takes an event that is based on clicking on a button.\\n  // Returns nothing.\\n  onClick(event: React.MouseEvent<HTMLButtonElement>): void;\\n};\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"A standalone function that you type as your declare it, is a little bit different.\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"const add = (a: number, b: number): number => {\\n  return a + b;\\n};\\n\\nfunction subtract(a: number, b: number): number {\\n  return a - b;\\n}\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Finally, we should consider the fact that not every \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"prop\"), \" is required.\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"type UserProps = {\\n  requiredProp: boolean;\\n  optionalProp?: string;\\n};\\n\"))), mdx(\"section\", null, mdx(\"h3\", {\n    parentName: \"section\"\n  }, \"Types Versus Interfaces\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"The short answer: By and large, it doesn't really matter. (But, that answer probably isn't good enough for your curiosity, is it?)\"), mdx(\"ul\", {\n    parentName: \"section\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Interfaces\"), \" are commonly used for defining the shape of objects and classes.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"You might however just want to define a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"type\"), \" of function or a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"type\"), \" alias, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"types\"), \" are cool too.\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"From \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces\"\n  }, \"Microsoft's TypeScript Handbook\"), \":\"), mdx(\"blockquote\", {\n    parentName: \"section\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Type aliases and interfaces are very similar, and in many cases you can choose between them freely. Almost all features of an interface are available in type, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.\")), mdx(\"ul\", {\n    parentName: \"section\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"interfaces\"), \" for public APIs since the consumer can then extend them if needed.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Consider using \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"type\"), \" for your React Component Props and State, for consistency and because it is more constrained.\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"TL; DR you can extend interfaces. This is convenient, bit it can also make things more complicated. It's up to you to decide if this is a think that makes your life better or not.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/karoljmajewski/status/1082413696075382785\"\n  }, \"Here\"), \" is a fun chart to look at.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://pbs.twimg.com/media/DwV-oOsXcAIct2q?format=jpg&name=medium\",\n    \"alt\": \"Types Versus Interfaces\"\n  })), mdx(\"blockquote\", {\n    parentName: \"section\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"you can adopt a simple strategy: use interfaces to describe objects, use types for everything else.\"))), mdx(\"section\", null, mdx(\"h3\", {\n    parentName: \"section\"\n  }, \"Typing Children\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"I don't want to ruin the surprise for you, but\\nif all the code we write was solely about just strings and numbers,\\nwe'd be spending very little time together.\\nThings can get a little bit tricky when\\nwe want to use TypeScript to specify non-primitive types\\u2014namely other React components.\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"type BoxProps = { children: any };\\n\\nconst Box = ({ children }: BoxProps) => {\\n  return (\\n    <section style={{ padding: \\\"1em\\\", border: \\\"5px solid purple\\\" }}>\\n      {children}\\n    </section>\\n  );\\n};\\n\\nexport default function Application() {\\n  return (\\n    <Box>\\n      Just a string.\\n      <p>Some HTML that is not nested.</p>\\n      <Box>\\n        <h2>Another React component with one child.</h2>\\n      </Box>\\n      <Box>\\n        <h2>A nested React component with two children.</h2>\\n        <p>The second child.</p>\\n      </Box>\\n    </Box>\\n  );\\n}\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"As it stands in the above code, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"children\"), \" has the type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"any\"), \", which is basically an opt-out of every\\nthat TypeScript has to offer you. This isn't great.\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"so if take a close look at the code you will find\"), mdx(\"ul\", {\n    parentName: \"section\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Box\"), \" renders \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"children\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It can render more than one child.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"That child can be another React component.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"That child can be a standard HTML element.\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"But, what can we use to specify that a given prop should be another React component?\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Off the top of my head, here are some things that you could try.\"), mdx(\"ul\", {\n    parentName: \"section\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"JSX.Element\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"JSX.Element[]\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"JSX.Element | JSX.Element[]\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"React.ReactNode\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"React.ReactChildren\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"React.ReactChild[]\"))), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Why don't you take it for a spin and see what works best for you? in the next sandbox \\uD83D\\uDE09\"), mdx(\"iframe\", {\n    src: \"https://codesandbox.io/embed/typescript-children-h4lop?fontsize=14&hidenavigation=1&theme=dark\",\n    style: {\n      \"width\": \"100%\",\n      \"height\": \"500px\",\n      \"border\": \"0\",\n      \"borderRadius\": \"4px\",\n      \"overflow\": \"hidden\"\n    },\n    title: \"typescript-children\",\n    allow: \"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\",\n    sandbox: \"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n  }), mdx(\"p\", {\n    parentName: \"section\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Solution\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"How do we type this? Well. We have a few choices.\"), mdx(\"ul\", {\n    parentName: \"section\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"JSX.Element;\"), \": \\uD83D\\uDCA9 This doesn't account for arrays at all.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"JSX.Element | JSX.Element[];\"), \" \\uD83D\\uDE15 This doesn't accept strings.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"React.ReactChildren;\"), \": \\uD83E\\uDD2A Not at even an appropriate type; it's a utility function.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"React.ReactChild[];\"), \": \\uD83D\\uDE00 Accepts multiple children, but it doesn't accept a single child.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"React.ReactNode;\"), \": \\uD83C\\uDFC6 Accepts everything.\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"I know now you'r thinking what's the hell is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JSX.Element\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ReactNOde\"), \", keep calm and read \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://stackoverflow.com/a/58123882/6483379\"\n  }, \"this\"))), mdx(\"section\", null, mdx(\"h3\", {\n    parentName: \"section\"\n  }, \"Typing Styling\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"What if we wanted to make the box a little bit more customizable?\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"We'll explore the following:\"), mdx(\"ul\", {\n    parentName: \"section\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"How to type CSS properties.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"How to use an optional type.\")), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\"\n  }, \"import \\\"./styles.css\\\";\\n\\nimport * as React from \\\"react\\\";\\n\\n+ type BoxProps = { children: React.ReactNode; style?: React.CSSProperties };\\n\\nconst Box = ({ children, style = {} }: BoxProps) => {\\n  return (\\n+   <section style={{ padding: \\\"1em\\\", border: \\\"5px solid purple\\\", ...style }}>\\n      {children}\\n    </section>\\n  );\\n};\\n\\nexport default function Application() {\\n  return (\\n    <Box>\\n      Just a string.\\n      <p>Some HTML that is not nested.</p>\\n+      <Box style={{ borderColor: \\\"red\\\" }}>\\n        <h2>Another React component with one child.</h2>\\n      </Box>\\n      <Box>\\n        <h2>A nested React component with two children.</h2>\\n        <p>The second child.</p>\\n      </Box>\\n    </Box>\\n  );\\n}\\n\"))), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Interacting with Components\")), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Acknowledgment\"), mdx(Tip, {\n    mdxType: \"Tip\"\n  }, \"I am not writing all the content here, most of the explanations based on the workshop from  \", \" \", mdx(\"a\", {\n    href: \"https://twitter.com/stevekinney\",\n    target: \"_blank\"\n  }, \" Steve Kinney\"), \" \\xA9\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#why-use-typescript","title":"Why use TypeScript"},{"url":"#the-fundamentals","title":"The Fundamentals","items":[{"url":"#basics","title":"Basics"},{"url":"#refactoring-from-proptypes","title":"Refactoring from PropTypes"},{"url":"#commonly-used-props","title":"Commonly-Used Props"},{"url":"#types-versus-interfaces","title":"Types Versus Interfaces"},{"url":"#typing-children","title":"Typing Children"},{"url":"#typing-styling","title":"Typing Styling"}]},{"url":"#interacting-with-components","title":"Interacting with Components"},{"url":"#acknowledgment","title":"Acknowledgment"}]},"timeToRead":4,"parent":{"__typename":"File","relativePath":"components/reactjs/react-with-typescript.md","fields":null},"frontmatter":{"metaTitle":null,"showMetadata":true,"editable":true,"showPreviousNext":null,"showToc":true}},"gitBranch":{"name":"remotes/origin/dependabot/npm_and_yarn/lodash-4.17.21"},"gitCommit":{"hash":"517dd1f1e9c154b8cad3762435c7f01eea4d7bb6","date":"2021-12-17 01:37"}},"pageContext":{"id":"2a280570-ae4d-5bb7-b6b4-30ccae68f12f"}},"staticQueryHashes":["12478684","12478684","2882937274","2882937274","353167761","353167761","4106624947","4106624947"]}