{"componentChunkName":"component---src-templates-docs-js","path":"/components/warmup-react","result":{"data":{"site":{"siteMetadata":{"title":"Yonisfy","docsLocation":"https://github.com/mohammedelzanaty/yonisfy","docsLocationType":"github","editable":true}},"mdx":{"fields":{"id":"b6538d34-e264-581e-9327-3e1a6ab6d471","title":"Warm up Before React","slug":"/components/warmup-react"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Warm up Before React\",\n  \"showMetadata\": true,\n  \"editable\": true,\n  \"showToc\": true,\n  \"order\": 3\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"iframe\", {\n    width: \"100%\",\n    height: \"600\",\n    src: \"https://www.youtube.com/embed/w3ZwgdgCigM\",\n    title: \"YouTube video player\",\n    frameBorder: \"0\",\n    allow: \"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\",\n    allowFullScreen: true\n  }), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Var, let and const\"), mdx(\"ul\", {\n    parentName: \"section\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Scope\")), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A variable\\u2019s scope is the context in which the variable exists. The scope specifies from where you can access a variable and whether you have access to the variable in that context.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Before ES6 (2015), JavaScript had only Global Scope and Function Scope.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"ES6 introduced two important new JavaScript keywords: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"let\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"const\"), \". These two keywords provide \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Block Scope\"), \" in JavaScript.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"JavaScript has 3 types of scope:-\")))), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"/* Block Scope */\\n\\n{\\n  let x = 2;\\n}\\n// x can NOT be used here\\n\\n// Variables declared with the var keyword can NOT have block scope.\\n// Variables declared inside a { } block can be accessed from outside the block.\\n\\n// ___________________\\n/* Function scope */\\n\\n// Each function creates a new scope.\\n// Variables defined inside a function are not accessible (visible) from outside the function.\\n\\nfunction sayHello() {\\n  for (var i = 0; i < 10; i++) {\\n    console.log(i);\\n  }\\n\\n  console.log(i); //( will log) 11\\n}\\n\\nsayHello();\\n\\n// ___________________\\n/* Global scope */\\n// A variable declared outside a function, becomes GLOBAL.\\n\\nlet name = 'Mohammed Elzanaty';\\n// code here can use name\\n\\nfunction myFunction() {\\n  // code here can also use name\\n}\\n\")), mdx(\"ul\", {\n    parentName: \"section\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Summary:\\n\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"-\"), \" var:- the variable defined is visible in the entire function.\\n\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"-\"), \" let:- the variable defined is visible only in the block it is defined in.\\n\", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"-\"), \" const:- makes the variable a constant, Use const over let and let over var wherever possible\"))), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Objects\"), mdx(\"ul\", {\n    parentName: \"section\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"JavaScript has one complex data type, the Object data type, and\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"it has five simple data types: Number, String, Boolean, Undefined, and Null.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Property names can be a string or a number, but if the property name is a number, it has to be accessed with the bracket notation.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It is best to avoid using numbers as property names.\\n\\u2014 Object Literals\\n=> let homeObj = {}\\n=> let bagObj = {id: 0, name: \\\"bag\\\"}\\n\\u2014 Object Constructor\\n=> A constructor is a function used for initializing new objects, and you use the new keyword to call the constructor.\\n=> let person = new Object()\\n=> animal.color = 'white'\\n=> animal.age = 12\")), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"const person = {\\n  // objects in js are collections of key value pairs.\\n  name: 'Mohammed Elzanay',\\n  eat() {}, // this is another way defining a method member in an object is: `eat: function() {} //not recommended`\\n  thank() {},\\n};\\n\\n// to access an existing property The syntax is: object.property = value.\\n\")), mdx(\"ul\", {\n    parentName: \"section\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Above is an object with 1 property and 2 methods.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Invoking method of an object: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"person.eat()\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Accessing property of object:-\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When the property is known in advance: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"person[\\\"name\\\"]\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"person.name\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When the property is not known in advance:-\")), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"const propertyName = 'age';\\n// when the property\\u2019s name is not known in advance or the name is an invalid variable identifier\\n// The syntax is: object['property'] = value.\\nperson[propertyName] = '10';\\n\"))))), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"The this Keyword\"), mdx(\"ul\", {\n    parentName: \"section\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"this\"), \" keyword refers to the object it belongs to\")), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"const person = {\\n  firstName: 'Mohammed',\\n  lastName: 'Elzanay',\\n  fullName: function() {\\n    return this.firstName + ' ' + this.lastName\\n  },\\n  eat() { // same as \\\"sayHi: function(){...}\\\"\\n    console.log('Eat....')\\n    return this // this is a simple keyword in js which confuse a lot of js developer bcoz it doesn't behave same other programming languages like java ... in js  this always return a reference for the current object\\n  },\\n  thank(actionOne, actionTwo, actionThree) {\\n    return `As ${this.fullName()}, I want to thank you for watching and Please Don't Forget to ${actionOne}, ${actionTwo} and ${actionThree} \\uD83E\\uDD47`\\n  },\\n};\\n\\n//.. It has different values depending on where it is used:-\\n\\n/* 1. this in a Method */\\n    //- In an object method, this refers to the \\\"owner\\\" of the method.\\n    //- so now this refers to the person object.\\n    //- The value of this is the object \\u201Cbefore dot\\u201D, the one used to call the method.\\n    const fullName = person.fullName()\\n    fullName // -> \\\"Mohammed Elzanay\\\"\\n\\n/* 2. this in a Function */\\n    //- the value of this is determined by how the function is called\\n      // 1. if you called the function as an method in an object it will always return a reference to that object\\n      person.eat() // {firstName: \\\"Mohammed\\\", lastName: \\\"Elzanay\\\", fullName: \\u0192, eat: \\u0192, talk: \\u0192}\\n      // 2. if you called the function as a standalone object or outside if an object this will return\\n            // IT DEPEND\\n                // without strict mode will return the global object which is the window object in browser  the owner of the function is the default binding for this.\\n                const personEat = person.eat\\n                personEat() // -> \\\"[object Window]\\\"\\n                // with strict mode will return undefined bcoz In a JavaScript function with strict mode, JavaScript does not allow default binding.\\n                \\\"use strict\\\";\\n                const personEatStrictMode = person.eat\\n                personEatStrictMode() // -> \\\"undefined\\\"\\n                 // how to fix the issue for wrong binding\\n                 // this lead us to\\n\\n/* 3. Object Method Binding */\\n    //- we know that function in js is an object so if you\\n    const personEat = person.eat. //- will appear drop down with all the member of the eat object and we use these methods to bind a function to an specific object so when we call\\n    person.eat.bind(/* what you pass here as an argument will determine the value of this so if i pass the person object here the bind method will return a new instance of eat function with and set this to point to this person object. so now when we call eat function we will see this person object*/)\\n    const personEatBind = person.eat.bind(person) //-> {firstName: \\\"Mohammed\\\", lastName: \\\"Elzanay\\\", fullName: \\u0192, eat: \\u0192, talk: \\u0192}\\n\\n    // Ok Great but if we need to call the thank method from peron object with different parameter\\n    // in this case we use methods predefined in javascript like call, apply\\n      // 1. call\\n          // call is a method take a first argument and sets the \\\"this\\\" value, which is the object, on which the function is invoked upon. In this case, it's the \\\"person\\\" object above.\\n          // The rest of the parameters are the arguments to the actual function.\\n    person.thank.call(person, 'Like', 'Comment', 'Subscribe');  // Will return \\\"As Mohammed Elzanay, I want to thank you for watching and Please Don't Forget to Like, Comment and Subscribe \\uD83E\\uDD47\\\"\\n      // 2. apply\\n          // Similarly to call() method the first parameter, set it to this value\\n          // the only difference of apply, call method is the second parameter of apply method. accepts the arguments as an array\\n    person.thank.apply(person, ['Like', 'Comment', 'Subscribe']); // Will return \\\"As Mohammed Elzanay, I want to thank you for watching and Please Don't Forget to Like, Comment and Subscribe \\uD83E\\uDD47\\\"\\n    // Recap\\n    //- Call and Apply execute the current function immediately.\\n    //- Bind is a bit different. It returns a new function and allows you to set the this value now while allowing you to execute the function in the future.\\n\\n/* 4. this Alone */\\n    //- When used alone, the owner is the Global object, so this refers to the Global object.\\n    let x = this\\n    this // -> \\\"[object Window]\\\"\\n\\n/* 5. this in Event Handlers */\\n    //- In HTML event handlers, this refers to the HTML element that received the event:\\n    <button onclick=\\\"this.style.display='none'\\\">\\n      Click to Remove Me!\\n    </button>\\n\"))), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Arrow Functions\"), mdx(\"ul\", {\n    parentName: \"section\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"is a compact alternative to a traditional function expression, but is limited and can't be used in all situations.\\nDifferent ways of declaring functions:\")), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"const square = function (number) {\\n  return number * number;\\n};\\n// this is the old js starting from es6 we have a cleaner way to write the same code\\n// one parameter remove ()\\n// without parameter so put it like ()\\nconst square = number => {\\n  return number * number;\\n};\\nconst square = number => number * number;\\n\\n// let see a real example assume we have an array of products\\nconst products = [\\n  { id: 1, title: 'Fjallraven - Foldsack Fits 15 Laptops', price: 109.95 },\\n  { id: 2, title: 'Mens Casual Premium Slim Fit T-Shirts ', price: 22.3 },\\n  { id: 3, title: 'Mens Cotton Jacket', price: 55.99 },\\n  { id: 4, title: 'Mens Casual Slim Fit', price: 15.99 },\\n  { id: 5, title: \\\"John Hardy Women's Legends N\\\", price: 695 },\\n  { id: 6, title: 'Solid Gold Petite Micropave ', price: 168 },\\n  { id: 7, title: 'White Gold Plated Princess', price: 9.99 },\\n];\\n\\nproducts.filter(function (product) {\\n  return product.price > 20;\\n});\\n//  1. Remove the word \\\"function\\\" and place arrow between the argument and opening body bracket\\nproducts.filter(product => {\\n  return product.price > 20;\\n});\\n// 2. Remove the body braces and word \\\"return\\\" -- the return is implied.\\nproducts.filter(product => product.price > 20);\\n// 3. Remove the argument parentheses\\nproducts.filter(product => product.price > 20);\\n\"))), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Arrow Functions and this\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"const person = {\\n  eat() {\\n    setTimeout(function () {\\n      console.log('this', this)\\n    }, 1000)\\n  }\\n}\\n\\nperson.eat() // -> \\\"[object Window]\\\" bcoz callback function is not part of any object  it's a standalone function so return global object as we mention before\\n\\n// so to solve this in old days we use to\\neat() {\\n    // create a variable hold the value of this\\n    let self = this;\\n    setTimeout(function () {\\n      console.log('self', this)\\n    }, 1000)\\n  }\\n// but with arrow functions we don't need to do this as it will inherit the context of the code defined\\nsetTimeout( () => {\\n      console.log('self', this)\\n}, 1000)\\n\"))), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Array functions Map and filter\"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"\\n//- Each one of these methods will iterate over an array and perform a transformation or computation\\n//- Each will return a new array based on the function\\n\\n// 1. Map\\n  // The map() method is used for creating a new array from an existing one\\n  // applying function to each element of the array\\n  // In the callback, only the array element is required\\n  map([\\uD83C\\uDF3D, \\uD83D\\uDC2E, \\uD83D\\uDC14], cook)\\n  => [\\uD83C\\uDF7F, \\uD83C\\uDF54, \\uD83C\\uDF73]\\n\\n  // Example\\n  const numbers = [1, 2, 3, 4];\\n  const doubled = numbers.map(item => item * 2);\\n  console.log(doubled); // [2, 4, 6, 8]\\n\\n// 2. Filter\\n  // The filter() method takes each element in an array and it applies a conditional statement against it.\\n  // If this conditional returns true, the element gets pushed to the output array.\\n  // If the condition returns false, the element does not get pushed to the output array.\\n  // The syntax for filter is similar to map, except the callback function should return true to keep the element, or false otherwise.\\n  // In the callback, only the element is required.\\n  filter([\\uD83C\\uDF7F, \\uD83C\\uDF54, \\uD83C\\uDF73], isVegetarian)\\n  =>  [\\uD83C\\uDF7F, \\uD83C\\uDF73]\\n\\n  // Example\\n  const numbers = [1, 2, 3, 4];\\n  const evens = numbers.filter(item => item % 2 === 0);\\n  console.log(evens); // [2, 4]\\n\\n  const products = [\\n    { id: 1, title: 'Fjallraven - Foldsack Fits 15 Laptops', price: 109.95 },\\n    { id: 2, title: 'Mens Casual Premium Slim Fit T-Shirts ', price: 22.3 },\\n    { id: 3, title: 'Mens Cotton Jacket', price: 55.99 },\\n    { id: 4, title: 'Mens Casual Slim Fit', price: 15.99 },\\n    { id: 5, title: \\\"John Hardy Women's Legends N\\\", price: 695 },\\n    { id: 6, title: 'Solid Gold Petite Micropave ', price: 168 },\\n    { id: 7, title: 'White Gold Plated Princess', price: 9.99 },\\n  ];\\n\\n  products.filter(function (product) {\\n    return product.price > 20;\\n  });\\n\\n\")), mdx(\"p\", {\n    parentName: \"section\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.freecodecamp.org/news/javascript-map-reduce-and-filter-explained-with-examples/\"\n  }, \"soruce\"))), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Object Destructuring\"), mdx(\"ul\", {\n    parentName: \"section\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The object destructuring is a useful JavaScript feature to extract properties from objects and bind them to variables.\")), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"// problem\\nconst moZanaty = {\\n  name: 'Mohammed Elzanaty',\\n  job: 'Software Engineer',\\n  bio: 'A passionate teaching-lover, developer, writer, and autodidact.',\\n  funFact: 'I learned programming by chance \\uD83D\\uDE2D',\\n  address: {\\n    city: 'Egypt',\\n  },\\n};\\n\\nconst name = moZanaty.name;\\nconst job = moZanaty.job;\\nconst bio = moZanaty.bio;\\n\\n// The property moZanaty.name value is assigned to the variable name. Same way moZanaty.job value is assigned to job.\\n// Such a way to access properties and assign them to variables requires boilerplate code.\\n// By writing var name = moZanaty.name, you have to mention the name binding 2 times, and the same for realName.\\n\\n// That\\u2019s where the object destructuring syntax is useful\\n// you can read a property or more and assign its value to a variable without duplicating the property name.\\n\\n// so to refactor and apply object destructuring\\nconst { name, job, bio } = moZanaty;\\n\\n// but you will face multiple situations you find your self need this feature\\n// 1. Property to Variables\\nconst { name } = moZanaty;\\n// 2. Multiple properties\\n// just enumerate as many properties as you like adding commas , in between\\nconst { name, job, bio } = moZanaty;\\n// 3. Default Value\\n// If the destructed object doesn\\u2019t have the property specified in the destructuring assignment,\\n// then the variable is assigned with undefined.\\nconst { hasDog } = moZanaty;\\nconst { hasDog = 'Default Dog Value' } = moZanaty;\\n// 4. Alias\\n// If you\\u2019d like to create variables of different names than the properties,\\n// then you can use the aliasing feature of object destructuring\\nconst { name: fullName } = moZanaty;\\n// 5. Deep Property\\nconst {\\n  address: { city },\\n} = moZanaty;\\n// 6. Dynamic Property Name\\nconst { [propName]: identifier } = expression;\\n// propName expression should evaluate to a property name (usually a string),\\n// the identifier should indicate the variable name created after the destructuring.\\n// The second expression should evaluate to the object you\\u2019d like to destructur.\\n\\n// An equivalent code without object destructuring:\\n\\nconst identifier = expression[propName];\\n\\nconst prop = 'name';\\nconst { [prop]: name } = moZanaty; //=> Mohammed Elzanaty\\n\"))), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Spread Operator\"), mdx(\"ul\", {\n    parentName: \"section\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"spread operator allows you to spread out elements of an iterable object such as an array,a map, or a set.\")), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"\\nlet fruits = ['\\uD83C\\uDF4E','\\uD83C\\uDF4C','\\uD83C\\uDF4A'];\\nlet vegetables = ['\\uD83E\\uDD6C', '\\uD83C\\uDF3D', '\\uD83E\\uDD52', '\\uD83E\\uDD54']\\nlet moZanaty = {\\n  name: 'Mohammed Elzanaty',\\n  job: 'Software Engineer',\\n  bio: 'A passionate teaching-lover, developer, writer, and autodidact.',\\n};\\n\\n// 1. Copying an array\\n    // let say we need to create copy a fruits array to a new array\\n    let newFruitArray = [...fruits]\\n\\n// 2. Concatenating / Combined arrays\\n    let basket = [...fruits, ...vegetables]\\n\\n// 3. Spreading elements together with an individual element\\n    let newFruitArray = ['\\uD83C\\uDF49', ...fruits]\\n\\n// 4. Spread syntax for object literals\\n    let first = { name: 'mo'}\\n    let second = { tip: 'I see you not like, comment or subscribe yet' }\\n\\n    const moElzanaty = {...first, ..second, job: 'Software Engineer',}\\n\"))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#var-let-and-const","title":"Var, let and const"},{"url":"#objects","title":"Objects"},{"url":"#the-this-keyword","title":"The this Keyword"},{"url":"#arrow-functions","title":"Arrow Functions"},{"url":"#arrow-functions-and-this","title":"Arrow Functions and this"},{"url":"#array-functions-map-and-filter","title":"Array functions Map and filter"},{"url":"#object-destructuring","title":"Object Destructuring"},{"url":"#spread-operator","title":"Spread Operator"}]},"timeToRead":1,"parent":{"__typename":"File","relativePath":"components/warmup-react.md","fields":{"gitLogLatestAuthorName":"mohammedelzanaty","gitLogLatestAuthorEmail":"mohammedelzanaty129@gmail.com","gitLogLatestDate":"7 days ago"}},"frontmatter":{"metaTitle":null,"showMetadata":true,"editable":true,"showPreviousNext":null,"showToc":true}},"gitBranch":{"name":"main"},"gitCommit":{"hash":"be01ebeee47f62ccd93093baedc54e3201173ae3","date":"2021-09-07 11:25"}},"pageContext":{"id":"b6538d34-e264-581e-9327-3e1a6ab6d471"}},"staticQueryHashes":["12478684","12478684","2882937274","2882937274","353167761","353167761","4106624947","4106624947"]}